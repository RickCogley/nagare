# PROPOSAL: Template-Based File Generation for Nagare 2.0

**Status**: Proposal\
**Author**: Rick Cogley\
**Date**: 2025-06-27\
**Target**: Nagare 2.0

## Summary

Evolve Nagare from regex-based file updates to a template-based file generation system using Vento
templates (`.vto` files), similar to how Lume SSG processes templates with data merging.

## Motivation

Current challenges with regex-based updates:

- Error-prone pattern matching (as seen with the Salty deno.json corruption)
- Complex regex patterns needed for safe updates
- Limited ability to restructure files
- Difficult to handle complex file formats
- Manual edits can break patterns

## Proposed Solution

Implement a template-based system where files are generated from Vento templates (`.vto` files) with
merged release data.

## Design

### File Structure

```
my-project/
├── src/
│   └── version.ts          # Generated from template
├── _templates/             # Template directory (configurable)
│   ├── README.md.vto      # README template
│   ├── deno.json.vto      # deno.json template
│   ├── version.ts.vto     # Version file template
│   └── _includes/         # Shared template parts
│       └── badges.vto     # Reusable badge component
├── _data/                  # Data files (like Lume)
│   ├── project.yml        # Static project data
│   └── features.ts        # Dynamic data generator
├── nagare.config.ts
└── README.md              # Generated from template
```

### Template Examples

**_templates/README.md.vto** (using proper .vto extension):

````markdown
---
# Front matter for template-specific data
badges:
  - version
  - build
  - license
---

# {{ project.name }}

{{> "_includes/badges.vto" }}

{{ project.description }}

## Installation

{{- if runtime.deno }}

```bash
deno add @{{ package.scope }}/{{ package.name }}@{{ version }}
```
````

{{- /if }}

{{- if runtime.node }}

```bash
npm install @{{ package.scope }}/{{ package.name }}@{{ version }}
```

{{- /if }}

## Features

{{- for feature in features }}

- {{ feature.name }}{{ if feature.description }}: {{ feature.description }}{{ /if }} {{- /for }}

## Latest Changes (v{{ version }})

{{- if releaseNotes.added.length > 0 }}

### ✨ Added

{{- for item in releaseNotes.added }}

- {{ item }} {{- /for }} {{- /if }}

{{- if releaseNotes.fixed.length > 0 }}

### 🐛 Fixed

{{- for item in releaseNotes.fixed }}

- {{ item }} {{- /for }} {{- /if }}

[View Full Changelog](./CHANGELOG.md)

---

_Generated by [Nagare](https://github.com/RickCogley/nagare) on {{ buildDate | formatDate }}_

````
**_templates/_includes/badges.vto**:
```markdown
{{- for badge in badges }}
{{- if badge == "version" }}
![Version](https://img.shields.io/badge/version-{{ version }}-blue.svg)
{{- elif badge == "build" }}
![Build Date](https://img.shields.io/badge/build-{{ buildDate | formatDate }}-green.svg)
{{- elif badge == "license" }}
![License](https://img.shields.io/badge/license-{{ project.license }}-brightgreen.svg)
{{- /if }}
{{- /for }}
````

**_templates/deno.json.vto**:

```json
{
  "name": "@{{ package.scope }}/{{ package.name }}",
  "version": "{{ version }}",
  "description": "{{ project.description | escape }}",
  {{- if project.author }}
  "author": "{{ project.author | escape }}",
  {{- /if }}
  "license": "{{ project.license }}",
  "homepage": "{{ project.homepage }}",
  "repository": {
    "type": "git",
    "url": "{{ project.repository }}"
  },
  {{- if keywords.length > 0 }}
  "keywords": {{ keywords | json(2) }},
  {{- /if }}
  "exports": {{ exports | json(2) }},
  "tasks": {{ tasks | json(2) }},
  "imports": {{ imports | json(2) }},
  "compilerOptions": {{ compilerOptions | json(2) }}
}
```

### Configuration

**nagare.config.ts**:

```typescript
import type { NagareConfig } from "@rick/nagare";

export default {
  project: {
    name: "My App",
    description: "Amazing Deno application",
    repository: "https://github.com/user/my-app",
    license: "MIT",
  },

  // Template configuration
  templates: {
    // Directory containing .vto templates
    dir: "./_templates",

    // Template processing options
    options: {
      // Use front matter in templates
      frontMatter: true,
      // Auto-detect .vto files for configured outputs
      autoDetect: true,
      // Preserve formatting in generated files
      prettyPrint: true,
    },

    // Files to generate from templates
    outputs: [
      {
        template: "README.md.vto",
        output: "./README.md",
        // File-specific data
        data: {
          features: [
            { name: "Fast", description: "Lightning quick performance" },
            { name: "Secure", description: "Built with security in mind" },
            { name: "Type-safe", description: "Full TypeScript support" },
          ],
        },
      },
      {
        template: "deno.json.vto",
        output: "./deno.json",
        // Dynamic data function
        data: async (context) => ({
          tasks: await loadTasksFromConfig(),
          imports: await resolveImports(context.version),
        }),
      },
      {
        // Auto-detect: looks for ./src/version.ts.vto
        output: "./src/version.ts",
      },
    ],
  },

  // Data sources (like Lume's _data)
  data: {
    // Load from data files
    files: [
      "./_data/project.yml",
      "./_data/features.json",
    ],

    // Global data
    global: {
      package: {
        scope: "myorg",
        name: "myapp",
      },
      runtime: {
        deno: true,
        node: false,
        bun: false,
      },
    },

    // Dynamic data generators
    generators: {
      // Function that returns data
      buildInfo: async () => ({
        timestamp: new Date().toISOString(),
        environment: Deno.env.get("NODE_ENV") || "production",
        gitBranch: await getGitBranch(),
      }),

      // Can access other data
      contributors: async (data) => {
        const commits = await getCommitsSince(data.lastRelease);
        return extractContributors(commits);
      },
    },
  },
} satisfies NagareConfig;
```

### Data Files Support

**_data/project.yml**:

```yaml
keywords:
  - release-management
  - versioning
  - deno
  - typescript

exports:
  .: ./mod.ts
  ./cli: ./cli.ts

social:
  twitter: "@rickcogley"
  github: "RickCogley"
```

**_data/features.ts**:

```typescript
// Dynamic data file (executed during release)
export default async function () {
  const features = await Deno.readTextFile("./FEATURES.md");
  return {
    features: parseFeatures(features),
    featureCount: features.split("\n").length,
  };
}
```

### Implementation Details

```typescript
class TemplateProcessor {
  private vento: Vento;
  private dataCache: Map<string, unknown>;

  constructor(private config: NagareConfig) {
    this.vento = vento({
      dataVarname: "it", // Like Lume
      autoescape: false, // We handle escaping per-context
    });

    this.setupFilters();
  }

  /**
   * Process all configured templates
   */
  async processTemplates(releaseData: ReleaseData): Promise<void> {
    // Load all data sources
    const data = await this.loadAllData(releaseData);

    // Process each output
    for (const output of this.config.templates.outputs) {
      await this.processTemplate(output, data);
    }
  }

  /**
   * Load and merge all data sources
   */
  private async loadAllData(releaseData: ReleaseData): Promise<TemplateData> {
    const data: TemplateData = {
      // Core release data
      ...releaseData,

      // Project configuration
      project: this.config.project,

      // Global data
      ...this.config.data?.global || {},
    };

    // Load data files
    if (this.config.data?.files) {
      for (const file of this.config.data.files) {
        const fileData = await this.loadDataFile(file);
        Object.assign(data, fileData);
      }
    }

    // Execute data generators
    if (this.config.data?.generators) {
      for (const [key, generator] of Object.entries(this.config.data.generators)) {
        data[key] = await generator(data);
      }
    }

    return data;
  }

  /**
   * Load a data file (YAML, JSON, or TS)
   */
  private async loadDataFile(path: string): Promise<Record<string, unknown>> {
    if (path.endsWith(".yml") || path.endsWith(".yaml")) {
      const content = await Deno.readTextFile(path);
      return parseYAML(content);
    }

    if (path.endsWith(".json")) {
      const content = await Deno.readTextFile(path);
      return JSON.parse(content);
    }

    if (path.endsWith(".ts") || path.endsWith(".js")) {
      const module = await import(path);
      if (typeof module.default === "function") {
        return await module.default();
      }
      return module.default || module;
    }

    throw new Error(`Unsupported data file format: ${path}`);
  }

  /**
   * Set up Vento filters
   */
  private setupFilters(): void {
    // JSON stringification with indentation
    this.vento.filters.json = (value: unknown, indent = 2) => {
      return JSON.stringify(value, null, indent);
    };

    // Date formatting
    this.vento.filters.formatDate = (date: Date | string) => {
      return new Date(date).toLocaleDateString();
    };

    // Escape for JSON strings
    this.vento.filters.escape = (str: string) => {
      return str.replace(/"/g, '\\"').replace(/\n/g, "\\n");
    };

    // Markdown to HTML (if needed)
    this.vento.filters.markdown = async (text: string) => {
      // Could use a markdown processor here
      return text;
    };
  }
}
```

### Migration Strategy

1. **Phase 1**: Add template support alongside existing pattern-based updates
2. **Phase 2**: Provide migration tools to convert patterns to templates
3. **Phase 3**: Deprecate pattern-based updates in favor of templates

### Benefits

1. **No Regex Complexity**: Templates define the entire file structure
2. **Type Safety**: Can validate generated JSON/YAML at compile time
3. **Reusability**: Shared includes and components
4. **Flexibility**: Full programming logic in templates
5. **Testability**: Easy to test template output
6. **GitHub Integration**: `.vto` files will have syntax highlighting

### Challenges

1. **Breaking Change**: Different mental model from current approach
2. **Manual Edits**: Generated files shouldn't be manually edited
3. **Complexity**: More setup required for simple cases
4. **Migration**: Existing projects need migration path

### Alternatives Considered

1. **Keep regex-only**: Too error-prone for complex cases
2. **Use different template engine**: Vento integrates well with Deno/Lume ecosystem
3. **Custom template syntax**: Unnecessary when Vento exists

### Migration Example

Current approach:

```typescript
updateFiles: [{
  path: "./README.md",
  patterns: {
    version: /badge\/version-([^-]+)-/g,
  },
}];
```

New approach:

```typescript
templates: {
  outputs: [{
    output: "./README.md",
    // Auto-detects ./README.md.vto or ./_templates/README.md.vto
  }];
}
```

### Open Questions

1. Should we support inline templates in config for simple cases?
2. How to handle files that users want to edit manually?
3. Should we auto-generate .vto templates from existing files?
4. What's the best migration tool design?

### Conclusion

This template-based approach would make Nagare more powerful and reliable, following established
patterns from successful tools like Lume. The use of `.vto` extension ensures good tooling support
and clear separation between templates and generated files.

## Next Steps

1. Implement proof-of-concept in Nagare 1.2.0 as experimental feature
2. Gather feedback from early adopters
3. Refine API based on real-world usage
4. Full implementation in Nagare 2.0 with migration tools
